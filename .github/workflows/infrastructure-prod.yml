name: Infrastructure Prod Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'infra/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'infra/**'
      - '.github/workflows/infrastructure.yml'

env:
  TF_VERSION: '1.6.1'
  AWS_REGION: 'us-east-1'
  TF_VAR_region: 'us-east-1'

jobs:
  validate:
    uses: ./.github/workflows/reusable-terraform-validate.yml

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [validate]
    if: github.event_name == 'pull_request'
    
    strategy:
      matrix: 
        environment: [staging] # Using staging for PR plans against main
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Terraform Init
      run: |
        terraform init \
          -backend-config="bucket=ons-data-platform-terraform-state-${{ matrix.environment }}" \
          -backend-config="key=terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=ons-data-platform-terraform-locks-${{ matrix.environment }}"
      working-directory: infra
    
    - name: Terraform Plan
      id: plan
      run: |
        terraform plan \
          -var="environment=${{ matrix.environment }}" \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -out=tfplan-${{ matrix.environment }} \
          -detailed-exitcode > plan.log 2>&1
        PLAN_EXIT_CODE=$?
        echo "exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
        if [ $PLAN_EXIT_CODE -ne 0 ] && [ $PLAN_EXIT_CODE -ne 2 ]; then
          echo "Terraform plan failed. See full log below."
          cat plan.log
          exit $PLAN_EXIT_CODE
        fi
      working-directory: infra
      continue-on-error: false
    
    - name: Generate plan summary
      run: |
        terraform show -no-color tfplan-${{ matrix.environment }} > tfplan-${{ matrix.environment }}.txt
        
        echo "## Terraform Plan Summary for ${{ matrix.environment }}" > plan-summary-${{ matrix.environment }}.md
        echo "" >> plan-summary-${{ matrix.environment }}.md
        
        if [ "${{ steps.plan.outputs.exitcode }}" == "0" ]; then
          echo "‚úÖ No changes detected" >> plan-summary-${{ matrix.environment }}.md
        elif [ "${{ steps.plan.outputs.exitcode }}" == "2" ]; then
          echo "üìã Changes detected:" >> plan-summary-${{ matrix.environment }}.md
          echo "" >> plan-summary-${{ matrix.environment }}.md
          echo '```hcl' >> plan-summary-${{ matrix.environment }}.md
          head -50 tfplan-${{ matrix.environment }}.txt >> plan-summary-${{ matrix.environment }}.md
          echo '```' >> plan-summary-${{ matrix.environment }}.md
        else
          echo "‚ùå Plan failed" >> plan-summary-${{ matrix.environment }}.md
        fi
      working-directory: infra
    
    - name: Upload plan artifacts
      uses: actions/upload-artifact@v3
      with:
        name: terraform-plan-${{ matrix.environment }}
        path: |
          infra/tfplan-${{ matrix.environment }}
          infra/tfplan-${{ matrix.environment }}.txt
          infra/plan-summary-${{ matrix.environment }}.md
    
    - name: Comment PR with Plan
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');
          
          try {
            const planSummary = fs.readFileSync('infra/plan-summary-${{ matrix.environment }}.md', 'utf8');
            
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.data.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Terraform Plan Summary for ${{ matrix.environment }}')
            );
            
            const commentBody = `${planSummary}\n            
            <details>
            <summary>Plan Details</summary>
            
            **Exit Code:** ${{ steps.plan.outputs.exitcode }}
            **Environment:** ${{ matrix.environment }}
            **Commit:** ${context.sha.substring(0, 7)}
            
            </details>`;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: commentBody
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: commentBody
              });
            }
          } catch (error) {
            console.error('Error posting plan comment:', error);
          }

  terraform-apply-production:
    name: Terraform Apply (Production)
    runs-on: ubuntu-latest
    needs: [validate]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - name: Setup Terraform state infrastructure
      run: |
        chmod +x scripts/setup-terraform-state.sh
        ./scripts/setup-terraform-state.sh
      env:
        AWS_REGION: ${{ env.AWS_REGION }}
    - name: Terraform Init
      run: |
        terraform init \
          -backend-config="bucket=ons-data-platform-terraform-state-prod" \
          -backend-config="key=terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=ons-data-platform-terraform-locks-prod"
      working-directory: infra
    - name: Terraform Destroy
      if: env.TERRAFORM_DESTROY_ENABLED == 'true'
      run: terraform destroy -auto-approve
      working-directory: infra
    - name: Terraform Plan
      id: plan
      run: |
        set +e
        terraform plan \
          -var="environment=prod" \
          -var="aws_region=${{ env.AWS_REGION }}" \
          -out=tfplan-prod \
          -detailed-exitcode
        PLAN_EXIT_CODE=$?
        echo "exitcode=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
        echo "Terraform plan exit code: $PLAN_EXIT_CODE"
        if [ $PLAN_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ No changes detected"
        elif [ $PLAN_EXIT_CODE -eq 2 ]; then
          echo "üìã Changes detected - will apply"
        else
          echo "‚ùå Plan failed with exit code $PLAN_EXIT_CODE"
          exit $PLAN_EXIT_CODE
        fi
      working-directory: infra
    - name: Terraform Apply
      if: steps.plan.outputs.exitcode == '2'
      run: |
        echo "üöÄ Applying Terraform changes..."
        terraform apply -compact-warnings -no-color tfplan-prod
        echo "‚úÖ Terraform apply completed successfully"
      working-directory: infra
    - name: Post-deployment validation
      run: |
        terraform output -json > outputs.json
        REQUIRED_OUTPUTS=("api_gateway_url" "s3_bucket_names" "lambda_function_names")
        for output in "${REQUIRED_OUTPUTS[@]}"; do
          if jq -e ".$output" outputs.json > /dev/null; then
            echo "‚úÖ Required output '$output' found"
          else
            echo "‚ö†Ô∏è Required output '$output' missing"
          fi
        done
        aws s3 ls | grep ons-data-platform || echo "‚ö†Ô∏è No ONS data platform S3 buckets found"
        aws lambda list-functions --query 'Functions[?contains(FunctionName, `ons-data-platform`)].FunctionName' --output table || echo "‚ö†Ô∏è No ONS data platform Lambda functions found"
        echo "Post-deployment validation completed"
      working-directory: infra

  cross-component-validation:
    name: Cross-Component Validation
    runs-on: ubuntu-latest
    needs: [terraform-apply-production]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - name: Validate infrastructure dependencies
      run: |
        echo "Validating cross-component dependencies..."
        EVENTBRIDGE_RULES=$(aws events list-rules --query 'Rules[?contains(Name, `ons-data-platform`)].Name' --output text)
        if [ -n "$EVENTBRIDGE_RULES" ]; then
          echo "‚úÖ EventBridge rules found: $EVENTBRIDGE_RULES"
          for rule in $EVENTBRIDGE_RULES; do
            TARGETS=$(aws events list-targets-by-rule --rule "$rule" --query 'Targets[].Arn' --output text)
            if [ -n "$TARGETS" ]; then
              echo "‚úÖ Rule $rule has targets: $TARGETS"
            else
              echo "‚ö†Ô∏è Rule $rule has no targets"
            fi
          done
        else
          echo "‚ö†Ô∏è No EventBridge rules found"
        fi
        STATE_MACHINES=$(aws stepfunctions list-state-machines --query 'stateMachines[?contains(name, `ons-data-platform`)].name' --output text)
        if [ -n "$STATE_MACHINES" ]; then
          echo "‚úÖ Step Functions found: $STATE_MACHINES"
        else
          echo "‚ö†Ô∏è No Step Functions state machines found"
        fi
        APIS=$(aws apigateway get-rest-apis --query 'items[?contains(name, `ons-data-platform`)].id' --output text)
        if [ -n "$APIS" ]; then
          echo "‚úÖ API Gateway found: $APIS"
        else
          echo "‚ö†Ô∏è No API Gateway found"
        fi
        echo "Cross-component validation completed"

  update-shared-state:
    name: Update Shared State Management
    runs-on: ubuntu-latest
    needs: [cross-component-validation]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    - name: Update state metadata
      run: |
        cd infra
        terraform init \
          -backend-config="bucket=ons-data-platform-terraform-state-prod" \
          -backend-config="key=terraform.tfstate" \
          -backend-config="region=${{ env.AWS_REGION }}" \
          -backend-config="dynamodb_table=ons-data-platform-terraform-locks-prod"
        
        terraform output -json > deployment-outputs.json
        
        DEPLOYMENT_METADATA=$(cat << EOF
        {
          "deployment_id": "${{ github.run_id }}",
          "commit_sha": "${{ github.sha }}",
          "deployed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "deployed_by": "${{ github.actor }}",
          "environment": "prod",
          "terraform_version": "${{ env.TF_VERSION }}"
        }
        EOF
        )
        
        echo "$DEPLOYMENT_METADATA" > deployment-metadata.json
        
        aws s3 cp deployment-metadata.json s3://ons-data-platform-terraform-state-prod/metadata/deployment-${{ github.run_id }}.json
        aws s3 cp deployment-outputs.json s3://ons-data-platform-terraform-state-prod/metadata/outputs-${{ github.run_id }}.json
        
        echo "‚úÖ Shared state metadata updated"
